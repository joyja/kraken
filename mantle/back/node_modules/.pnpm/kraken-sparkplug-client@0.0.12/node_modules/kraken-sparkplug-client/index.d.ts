/// <reference types="node" />
/**
 * Copyright (c) 2016-2017 Cirrus Link Solutions
 *
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Cirrus Link Solutions
 */
import * as mqtt from 'mqtt';
import type { IClientOptions } from 'mqtt';
import events from 'events';
import type { UPayload, UTemplate, UDataSet, UMetric } from 'sparkplug-payload/lib/sparkplugbpayload';
export declare type ISparkplugClientOptions = {
    serverUrl: string;
    username: string;
    password: string;
    groupId: string;
    edgeNode: string;
    clientId: string;
    publishDeath?: boolean;
    version?: string;
    keepalive?: number;
    mqttOptions?: Omit<IClientOptions, 'clientId' | 'clean' | 'keepalive' | 'reschedulePings' | 'connectTimeout' | 'username' | 'password' | 'will'>;
};
export declare type ISparkplugHostOptions = {
    serverUrl: string;
    username: string;
    password: string;
    primaryHostId: string;
    clientId: string;
    version?: string;
    keepalive?: number;
    mqttOptions?: Omit<IClientOptions, 'clientId' | 'clean' | 'keepalive' | 'reschedulePings' | 'connectTimeout' | 'username' | 'password' | 'will' | 'primaryHostId'>;
};
export declare type PayloadOptions = {
    algorithm?: 'GZIP' | 'DEFLATE';
    /** @default false */
    compress?: boolean;
};
interface SparkplugClient extends events.EventEmitter {
    /** MQTT client event */
    on(event: 'connect' | 'close' | 'reconnect' | 'offline', listener: () => void): this;
    /** MQTT client event */
    on(event: 'error', listener: (error: Error) => void): this;
    /** emitted when birth messages are ready to be sent*/
    on(event: 'birth', listener: () => void): this;
    /** emitted when a node command is received */
    on(event: 'ncmd', listener: (payload: UPayload) => void): this;
    /** emitted when a device command is received */
    on(event: 'dcmd', listener: (device: string, payload: UPayload) => void): this;
    /** emitted when a primaryHost state changes */
    on(event: 'state', listener: (primaryHost: string, payload: string) => void): this;
    /** emitted when a payload is received with a version unsupported by this client */
    on(event: 'message', listener: (topic: string, payload: UPayload) => void): this;
    emit(event: 'connect' | 'close' | 'reconnect' | 'offline' | 'birth'): boolean;
    emit(event: 'error', error: Error): boolean;
    emit(event: 'ncmd', payload: UPayload): boolean;
    emit(event: 'dcmd', device: string, payload: UPayload): boolean;
    emit(event: 'message', topic: string, payload: Buffer): boolean;
    emit(event: 'state', topic: string, payload: Buffer): boolean;
}
interface SparkplugHost extends events.EventEmitter {
    /** MQTT client event */
    on(event: 'connect' | 'close' | 'reconnect' | 'offline', listener: () => void): this;
    /** MQTT client event */
    on(event: 'error', listener: (error: Error) => void): this;
    /** emitted when birth messages are ready to be sent*/
    on(event: 'birth', listener: () => void): this;
    /** emitted when a node command is received */
    on(event: 'ncmd', listener: (payload: UPayload) => void): this;
    /** emitted when a device command is received */
    on(event: 'dcmd', listener: (device: string, payload: UPayload) => void): this;
    on(event: 'ddata' | 'dbirth' | 'ddeath', listener: (topic: string, groupId: string, node: string, deviceId: string, payload: UPayload) => void): this;
    on(event: 'nbirth' | 'ndeath', listener: (topic: string, groupId: string, node: string, payload: UPayload) => void): this;
    on(event: 'message', listener: (topic: string, payload: UPayload) => void): this;
    emit(event: 'connect' | 'close' | 'reconnect' | 'offline' | 'birth'): boolean;
    emit(event: 'error', error: Error): boolean;
    emit(event: 'ddata' | 'dbirth' | 'ddeath', topic: string, groupId: string, node: string, deviceId: string, payload: UPayload): boolean;
    emit(event: 'nbirth' | 'ndeath', topic: string, groupId: string, node: string, payload: UPayload): boolean;
    emit(event: 'message', topic: string, payload: Buffer): boolean;
    emit(event: 'state', topic: string, payload: Buffer): boolean;
    emit(event: 'ncmd', payload: UPayload): boolean;
    emit(event: 'dcmd', device: string, payload: UPayload): boolean;
}
export { UPayload, UTemplate, UDataSet, UMetric };
declare class SparkplugClient extends events.EventEmitter {
    private readonly type_int32;
    private readonly type_boolean;
    private readonly type_string;
    private readonly versionB;
    private serverUrl;
    private groupId;
    private edgeNode;
    private publishDeath;
    private version;
    private mqttOptions;
    private bdSeq;
    private seq;
    private client;
    private connecting;
    private connected;
    constructor(config: ISparkplugClientOptions);
    private incrementSeqNum;
    private encodePayload;
    private decodePayload;
    private addSeqNumber;
    private getDeathPayload;
    private publishNDeath;
    private messageAlert;
    private compressPayload;
    private decompressPayload;
    private maybeCompressPayload;
    private maybeDecompressPayload;
    subscribeTopic(topic: string, options?: mqtt.IClientSubscribeOptions, callback?: mqtt.ClientSubscribeCallback): void;
    unsubscribeTopic(topic: string, options?: any, callback?: mqtt.PacketCallback): void;
    publishNodeBirth(payload: UPayload, options?: PayloadOptions): void;
    publishNodeData(payload: UPayload, options?: PayloadOptions): void;
    publishDeviceData(deviceId: string, payload: UPayload, options?: PayloadOptions): void;
    publishDeviceBirth(deviceId: string, payload: UPayload, options?: PayloadOptions): void;
    publishDeviceDeath(deviceId: string, payload: UPayload): void;
    stop(): void;
    private init;
}
export declare function newClient(config: ISparkplugClientOptions): SparkplugClient;
declare class SparkplugHost extends events.EventEmitter {
    private readonly type_int32;
    private readonly type_boolean;
    private readonly type_string;
    private readonly versionB;
    private serverUrl;
    private version;
    private primaryHostId;
    private mqttOptions;
    private bdSeq;
    private seq;
    private client;
    private connecting;
    private connected;
    constructor(config: ISparkplugHostOptions);
    private incrementSeqNum;
    private encodePayload;
    private decodePayload;
    private addSeqNumber;
    private getDeathPayload;
    private messageAlert;
    private compressPayload;
    private decompressPayload;
    private maybeCompressPayload;
    private maybeDecompressPayload;
    subscribeTopic(topic: string, options?: mqtt.IClientSubscribeOptions, callback?: mqtt.ClientSubscribeCallback): void;
    unsubscribeTopic(topic: string, options?: any, callback?: mqtt.PacketCallback): void;
    publishHostOnline(): void;
    publishHostOffline(): void;
    publishNodeCommand(groupId: string, nodeId: string, payload: UPayload, options?: PayloadOptions): void;
    publishDeviceCommand(groupId: string, nodeId: string, deviceId: string, payload: UPayload, options?: PayloadOptions): void;
    stop(): void;
    private init;
}
export declare function newHost(config: ISparkplugHostOptions): SparkplugHost;
//# sourceMappingURL=index.d.ts.map